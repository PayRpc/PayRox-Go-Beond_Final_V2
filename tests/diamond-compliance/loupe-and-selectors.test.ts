import { expect } from "chai";
import { ethers } from "hardhat";
import { Contract } from "ethers";
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";

/**
 * PayRox Diamond Compliance Tests
 * 
 * Validates EIP-2535 Diamond Pattern compliance:
 * - Loupe function implementations
 * - Selector routing correctness
 * - Interface support (ERC-165)
 */

describe("Loupe and Selectors", function () {
  let diamond: Contract;
  let facets: Contract[];
  let expectedSelectors: string[];

  async function deployDiamondFixture() {
    const [owner, addr1] = await ethers.getSigners();

    // Deploy facets (this would be generated by the refactor copilot)
    const FacetA = await ethers.getContractFactory("FacetA");
    const FacetB = await ethers.getContractFactory("FacetB");
    
    const facetA = await FacetA.deploy();
    const facetB = await FacetB.deploy();

    // Deploy diamond
    const Diamond = await ethers.getContractFactory("Diamond");
    const diamond = await Diamond.deploy(owner.address);

    // Add facets to diamond (using DiamondCutFacet)
    const diamondCut = await ethers.getContractAt("IDiamondCut", diamond.address);
    
    // Get function selectors for each facet
    const facetASelectors = getSelectors(facetA);
    const facetBSelectors = getSelectors(facetB);

    await diamondCut.diamondCut(
      [
        {
          facetAddress: facetA.address,
          action: 0, // Add
          functionSelectors: facetASelectors
        },
        {
          facetAddress: facetB.address,
          action: 0, // Add
          functionSelectors: facetBSelectors
        }
      ],
      ethers.constants.AddressZero,
      "0x"
    );

    return { 
      diamond, 
      facetA, 
      facetB, 
      owner, 
      addr1,
      expectedSelectors: [...facetASelectors, ...facetBSelectors]
    };
  }

  beforeEach(async function () {
    const fixture = await loadFixture(deployDiamondFixture);
    diamond = fixture.diamond;
    facets = [fixture.facetA, fixture.facetB];
    expectedSelectors = fixture.expectedSelectors;
  });

  describe("IDiamondLoupe Implementation", function () {
    it("Should implement facets() function", async function () {
      const diamondLoupe = await ethers.getContractAt("IDiamondLoupe", diamond.address);
      
      const facetAddresses = await diamondLoupe.facets();
      expect(facetAddresses.length).to.be.greaterThan(0);
      
      // Verify facet addresses are valid
      for (const facet of facetAddresses) {
        expect(facet.facetAddress).to.not.equal(ethers.constants.AddressZero);
        expect(facet.functionSelectors.length).to.be.greaterThan(0);
      }
    });

    it("Should implement facetFunctionSelectors()", async function () {
      const diamondLoupe = await ethers.getContractAt("IDiamondLoupe", diamond.address);
      
      for (const facet of facets) {
        const selectors = await diamondLoupe.facetFunctionSelectors(facet.address);
        expect(selectors.length).to.be.greaterThan(0);
        
        // Verify selectors are valid bytes4
        for (const selector of selectors) {
          expect(selector).to.match(/^0x[a-fA-F0-9]{8}$/);
        }
      }
    });

    it("Should implement facetAddresses()", async function () {
      const diamondLoupe = await ethers.getContractAt("IDiamondLoupe", diamond.address);
      
      const addresses = await diamondLoupe.facetAddresses();
      expect(addresses.length).to.be.greaterThan(0);
      
      // Should include all deployed facet addresses
      const facetAddresses = facets.map(f => f.address);
      for (const addr of facetAddresses) {
        expect(addresses).to.include(addr);
      }
    });

    it("Should implement facetAddress(bytes4)", async function () {
      const diamondLoupe = await ethers.getContractAt("IDiamondLoupe", diamond.address);
      
      for (const selector of expectedSelectors) {
        const facetAddress = await diamondLoupe.facetAddress(selector);
        expect(facetAddress).to.not.equal(ethers.constants.AddressZero);
      }
    });

    it("Should return zero address for unknown selectors", async function () {
      const diamondLoupe = await ethers.getContractAt("IDiamondLoupe", diamond.address);
      
      const unknownSelector = "0x12345678";
      const facetAddress = await diamondLoupe.facetAddress(unknownSelector);
      expect(facetAddress).to.equal(ethers.constants.AddressZero);
    });
  });

  describe("Selector Routing", function () {
    it("Should route all selectors correctly", async function () {
      const diamondLoupe = await ethers.getContractAt("IDiamondLoupe", diamond.address);
      
      // Test each expected selector
      for (const selector of expectedSelectors) {
        const facetAddress = await diamondLoupe.facetAddress(selector);
        expect(facetAddress).to.not.equal(ethers.constants.AddressZero);
        
        // Verify the facet actually has this selector
        const facetSelectors = await diamondLoupe.facetFunctionSelectors(facetAddress);
        expect(facetSelectors).to.include(selector);
      }
    });

    it("Should have no selector collisions", async function () {
      const diamondLoupe = await ethers.getContractAt("IDiamondLoupe", diamond.address);
      const allFacets = await diamondLoupe.facets();
      
      const allSelectors: string[] = [];
      const selectorToFacet: Map<string, string> = new Map();
      
      for (const facet of allFacets) {
        for (const selector of facet.functionSelectors) {
          if (selectorToFacet.has(selector)) {
            throw new Error(
              `Selector collision: ${selector} found in both ${selectorToFacet.get(selector)} and ${facet.facetAddress}`
            );
          }
          selectorToFacet.set(selector, facet.facetAddress);
          allSelectors.push(selector);
        }
      }
      
      // Verify all selectors are unique
      const uniqueSelectors = [...new Set(allSelectors)];
      expect(uniqueSelectors.length).to.equal(allSelectors.length);
    });

    it("Should maintain selector parity with original contract", async function () {
      // This test would compare selectors with the original monolithic contract
      // Load expected selectors from manifest or selector map
      const fs = require('fs');
      const path = require('path');
      
      const manifestPath = path.join(process.cwd(), 'payrox-manifest.json');
      if (fs.existsSync(manifestPath)) {
        const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf-8'));
        const manifestSelectors: string[] = [];
        
        for (const facet of Object.values(manifest.facets) as any[]) {
          manifestSelectors.push(...facet.selectors);
        }
        
        const diamondLoupe = await ethers.getContractAt("IDiamondLoupe", diamond.address);
        const diamondFacets = await diamondLoupe.facets();
        const diamondSelectors: string[] = [];
        
        for (const facet of diamondFacets) {
          diamondSelectors.push(...facet.functionSelectors);
        }
        
        // Remove loupe selectors from comparison (they're added by diamond)
        const loupeSelectors = [
          "0x1f931c1c", // facets()
          "0xcdffacc6", // facetFunctionSelectors()
          "0x52ef6b2c", // facetAddresses()
          "0xadfca15e", // facetAddress()
          "0x01ffc9a7"  // supportsInterface()
        ];
        
        const filteredDiamondSelectors = diamondSelectors.filter(
          sel => !loupeSelectors.includes(sel)
        );
        
        expect(filteredDiamondSelectors.sort()).to.deep.equal(manifestSelectors.sort());
      }
    });
  });

  describe("ERC-165 Support", function () {
    it("Should support IDiamondLoupe interface", async function () {
      const diamond165 = await ethers.getContractAt("IERC165", diamond.address);
      
      // IDiamondLoupe interface ID: 0x48e2b093
      expect(await diamond165.supportsInterface("0x48e2b093")).to.be.true;
    });

    it("Should support ERC-165 interface", async function () {
      const diamond165 = await ethers.getContractAt("IERC165", diamond.address);
      
      // ERC-165 interface ID: 0x01ffc9a7
      expect(await diamond165.supportsInterface("0x01ffc9a7")).to.be.true;
    });

    it("Should not support unknown interfaces", async function () {
      const diamond165 = await ethers.getContractAt("IERC165", diamond.address);
      
      // Random interface ID
      expect(await diamond165.supportsInterface("0x12345678")).to.be.false;
    });
  });

  describe("Facet Constraints", function () {
    it("Facets should NOT implement loupe functions", async function () {
      // This test ensures facets don't claim loupe interface support
      for (const facet of facets) {
        try {
          const facet165 = await ethers.getContractAt("IERC165", facet.address);
          const supportsLoupe = await facet165.supportsInterface("0x48e2b093");
          expect(supportsLoupe).to.be.false;
        } catch (error) {
          // If facet doesn't implement ERC-165, that's acceptable
          // The key is it shouldn't claim loupe support
        }
        
        // Check that facet contracts don't have loupe function signatures
        const facetInterface = facet.interface;
        const facetFunctions = Object.keys(facetInterface.functions);
        
        const loupeFunctions = [
          'facets()',
          'facetFunctionSelectors(address)',
          'facetAddresses()',
          'facetAddress(bytes4)'
        ];
        
        for (const loupeFunc of loupeFunctions) {
          expect(facetFunctions).to.not.include(loupeFunc);
        }
      }
    });
  });
});

// Helper function to get function selectors from a contract
function getSelectors(contract: Contract): string[] {
  const selectors: string[] = [];
  
  for (const func of Object.values(contract.interface.functions)) {
    if (func.type === 'function') {
      selectors.push(func.selector);
    }
  }
  
  return selectors;
}

// Helper function to compute function selector
function computeSelector(signature: string): string {
  return ethers.utils.id(signature).slice(0, 10);
}
