import pkg from '../../package.json' with { type: 'json' };
import { now } from '@nomicfoundation/hardhat-utils/date';
import { readJsonFile, writeJsonFile } from '@nomicfoundation/hardhat-utils/fs';
import { sleep } from '@nomicfoundation/hardhat-utils/lang';
import envPaths from 'env-paths';
import { HardhatPluginError } from 'hardhat/plugins';
import path from 'node:path';
import readline from 'node:readline';
const cooldownIncrement = 86400;
const defaultFundingRequestData = {
    requestedAt: 0,
    cooldown: 0,
};
// TODO: set up multisig
const donationAddresses = {
    '0x7a69': '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
};
export const donateNativeToken = async (hre, amount, decimals = 18n) => {
    const { provider } = await hre.network.connect();
    const chainId = (await provider.request({
        method: 'eth_chainId',
    }));
    const to = donationAddresses[chainId];
    if (!to) {
        throw new HardhatPluginError(pkg.name, 'Unsupported chain id.');
    }
    const [from] = (await provider.request({
        method: 'eth_accounts',
    }));
    const value = String(amount * 10n ** decimals);
    const response = await hre.interruptions.requestInput(pkg.name, `Sending ${amount} native tokens (${value} wei) from account ${from}; proceed? (y/n)`);
    if (!['yes', 'y'].includes(response.toLowerCase())) {
        throw new HardhatPluginError(pkg.name, 'Transaction aborted.');
    }
    const hash = await provider.request({
        method: 'eth_sendTransaction',
        params: [{ from, to, value }],
    });
    console.log(`Transaction submitted with hash ${hash}.  Thank you!`);
};
export const delay = async (timeout = 10, delay = 0) => {
    await sleep(delay);
    if (timeout === 0)
        return;
    const rl = readline.promises.createInterface({
        input: process.stdin,
        output: process.stdout,
    });
    const aborter = new AbortController();
    setTimeout(aborter.abort.bind(aborter), timeout * 1000).unref();
    try {
        await rl.question(`Press <ENTER> to continue.\n`, {
            signal: aborter.signal,
        });
    }
    catch (error) {
        // rejected by aborter; do nothing
    }
    rl.close();
};
export const updateFundingRequestData = async () => {
    const data = await readFundingRequestData();
    await writeFundingRequestData({
        requestedAt: now(),
        cooldown: data.cooldown + cooldownIncrement,
    });
};
export const isFundingRequestReady = async () => {
    const data = await readFundingRequestData();
    return now() > data.requestedAt + data.cooldown;
};
const readFundingRequestData = async () => {
    try {
        const filePath = getFundingDataFilePath();
        return await readJsonFile(filePath);
    }
    catch (error) {
        return defaultFundingRequestData;
    }
};
const writeFundingRequestData = async (data) => {
    const filePath = getFundingDataFilePath();
    await writeJsonFile(filePath, data);
};
const getFundingDataFilePath = () => {
    return path.resolve(envPaths(pkg.name).data, 'funding.json');
};
