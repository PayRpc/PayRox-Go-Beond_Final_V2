{
  "name": "ManifestDispatcher",
  "code": "contract ManifestDispatcher is\n    IManifestDispatcher,\n    IDiamondLoupe,   // standard EIP-2535 loupe\n    IDiamondLoupeEx, // enhanced loupe (Ex)\n    AccessControl,\n    Pausable,\n    ReentrancyGuard\n{\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    // Roles\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    bytes32 public constant COMMIT_ROLE    = keccak256(\"COMMIT_ROLE\");\n    bytes32 public constant APPLY_ROLE     = keccak256(\"APPLY_ROLE\");\n    bytes32 public constant EMERGENCY_ROLE = keccak256(\"EMERGENCY_ROLE\");\n\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    // Limits\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    uint256 private constant MAX_BATCH = 100;\n    uint256 private constant MAX_FACET_CODE = 24_576; // EIP-170 limit\n    uint64  private constant MAX_ACTIVATION_DELAY = 365 days; // governance safety bound\n\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    // Storage\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    struct ManifestState {\n        bytes32 activeRoot;      // current manifest root\n        bytes32 pendingRoot;     // committed (not yet active) root\n        uint64  activeEpoch;     // current epoch\n        uint64  committedAt;     // when pendingRoot was set\n        uint64  activationDelay; // governance delay\n        uint64  manifestVersion; // bump on every apply/activate\n        bool    frozen;          // one-way lock of governance mutators\n    }\n    ManifestState public manifest;\n\n    // selector \u2192 Route\n    mapping(bytes4 => IManifestDispatcher.Route) private _routes;\n    // selector registry\n    mapping(bytes4 => bool) public registeredSelectors;\n\n    // Loupe registries\n    mapping(address => bytes4[]) public facetSelectors;\n    address[] private _facetAddresses;\n    uint256   public routeCount;\n\n    // Enhanced Loupe (Ex) metadata (lightweight)\n    mapping(address => uint8)   private _facetSecurityLevel; // default 1=user\n    mapping(address => bytes32) private _facetVersionTag;    // default 0x0 (unspecified)\n    mapping(address => address) private _facetDeployer;      // provenance (first registrar)\n    mapping(address => uint64)  private _facetDeployedAt;    // provenance timestamp\n\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    // Errors\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    error FrozenContract();\n    error NoRoute();\n    error CodehashMismatch();\n    error RootZero();\n    error BadEpoch();\n    error NoPendingRoot();\n    error ActivationNotReady(uint64 earliest, uint64 nowTs);\n    error BatchTooLarge(uint256 n);\n    error LenMismatch();\n    error FacetIsSelf();\n    error ZeroAddress();\n    error ZeroCodeFacet(address facet);\n    error CodeSizeExceeded(address facet, uint256 size);\n    error FacetCodeMismatch(address facet, bytes32 expected, bytes32 actual);\n    error DuplicateSelector(bytes4 selector);\n    error InvalidProof();\n    error ActivationDelayOutOfRange(uint64 newDelay);\n    error InvalidSecurityLevel(uint8 level);\n    error FacetUnknown(address facet);\n\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    // Events (contract-specific + some from interfaces are reused)\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    event ManifestVersionUpdated(uint64 indexed oldVersion, uint64 indexed newVersion);\n    event RoutesRemoved(bytes4[] selectors);\n    event RouteUpdated(bytes4 indexed selector, address indexed oldFacet, address indexed newFacet);\n    event FacetSecurityLevelSet(address indexed facet, uint8 level);\n    event FacetVersionTagSet(address indexed facet, bytes32 versionTag);\n\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    // Constructor\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    constructor(address admin, uint64 activationDelaySeconds) {\n        if (admin == address(0)) revert ZeroAddress();\n        // Enforce reasonable upper bound at deploy time\n        if (activationDelaySeconds > MAX_ACTIVATION_DELAY) revert ActivationDelayOutOfRange(activationDelaySeconds);\n\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(COMMIT_ROLE, admin);\n        _grantRole(APPLY_ROLE, admin);\n        _grantRole(EMERGENCY_ROLE, admin);\n\n        manifest.activationDelay = activationDelaySeconds;\n        manifest.manifestVersion = 1;\n    }\n\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    // Routing (fallback/receive)\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    receive() external payable {}\n\n    fallback() external payable whenNotPaused {\n        bytes4 selector = msg.sig;\n        IManifestDispatcher.Route storage r = _routes[selector];\n        address facet = r.facet;\n        if (facet == address(0)) revert NoRoute();\n\n        // EXTCODEHASH equality gate on every call\n        if (facet.codehash != r.codehash) revert CodehashMismatch();\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let ok := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            let sz := returndatasize()\n            returndatacopy(0, 0, sz)\n            switch ok\n            case 0 { revert(0, sz) }\n            default { return(0, sz) }\n        }\n    }\n\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    // Views (IManifestDispatcher)\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    function routes(bytes4 selector) external view override returns (address facet, bytes32 codehash) {\n        IManifestDispatcher.Route storage r = _routes[selector];\n        return (r.facet, r.codehash);\n    }\n\n    function pendingRoot()     external view override returns (bytes32) { return manifest.pendingRoot; }\n    function pendingEpoch()    external view override returns (uint64)  { return manifest.activeEpoch + 1; }\n    function pendingSince()    external view override returns (uint64)  { return manifest.committedAt; }\n    function activeRoot()      external view override returns (bytes32) { return manifest.activeRoot; }\n    function activeEpoch()     external view override returns (uint64)  { return manifest.activeEpoch; }\n    function activationDelay() external view override returns (uint64)  { return manifest.activationDelay; }\n    function frozen()          external view override returns (bool)    { return manifest.frozen; }\n\n    function getManifestVersion() external view returns (uint64) { return manifest.manifestVersion; }\n    function getRoute(bytes4 selector) external view returns (address) { return _routes[selector].facet; }\n    function getRouteCount() external view returns (uint256) { return routeCount; }\n\n    // New lightweight getters for facet metadata and limits\n    function facetSecurityLevel(address facet) external view returns (uint8) {\n        return _facetSecurityLevel[facet];\n    }\n\n    function facetVersionTag(address facet) external view returns (bytes32) {\n        return _facetVersionTag[facet];\n    }\n\n    function getLimits() external pure returns (uint256 maxBatch, uint256 maxFacetCode, uint64 maxActivationDelay) {\n        return (MAX_BATCH, MAX_FACET_CODE, MAX_ACTIVATION_DELAY);\n    }\n\n    function verifyManifest(bytes32 manifestHash) external view returns (bool ok, bytes32 current) {\n        current = manifest.activeRoot; ok = (manifestHash == current);\n    }\n\n    function getManifestInfo()\n        external\n        view\n        override\n        returns (IManifestDispatcher.ManifestInfo memory info)\n    {\n        info = IManifestDispatcher.ManifestInfo({\n            hash:          manifest.activeRoot,\n            version:       manifest.manifestVersion,\n            timestamp:     uint64(block.timestamp),\n            selectorCount: routeCount\n        });\n    }\n\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    // Manifest lifecycle\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n    /// @notice Commit a new manifest root for the next epoch (last write wins).\n    function commitRoot(bytes32 newRoot, uint64 newEpoch)\n        external\n        override\n        onlyRole(COMMIT_ROLE)\n        whenNotPaused\n    {\n        if (manifest.frozen) revert FrozenContract();\n        if (newRoot == bytes32(0)) revert RootZero();\n        if (newEpoch != manifest.activeEpoch + 1) revert BadEpoch();\n\n        manifest.pendingRoot = newRoot;\n        manifest.committedAt = uint64(block.timestamp);\n\n        emit RootCommitted(newRoot, newEpoch);\n    }\n\n    /// @notice Apply route updates proven against the committed root.\n    function applyRoutes(\n        bytes4[] calldata selectors,\n        address[] calldata facetAddrs,\n        bytes32[] calldata codehashes,\n        bytes32[][] calldata proofs,\n        bool[][]   calldata isRight\n    )\n        external\n        override\n        onlyRole(APPLY_ROLE)\n        whenNotPaused\n        nonReentrant\n    {\n        if (manifest.frozen) revert FrozenContract();\n        if (manifest.pendingRoot == bytes32(0)) revert NoPendingRoot();\n        uint256 n = selectors.length;\n        if (n == 0) return;\n        if (n != facetAddrs.length || n != codehashes.length || n != proofs.length || n != isRight.length)\n            revert LenMismatch();\n        if (n > MAX_BATCH) revert BatchTooLarge(n);\n\n        // de-dupe batch\n        for (uint256 i = 0; i < n; i++) {\n            for (uint256 j = i + 1; j < n; j++) {\n                if (selectors[i] == selectors[j]) revert DuplicateSelector(selectors[i]);\n            }\n        }\n\n        bytes32 root = manifest.pendingRoot;\n        for (uint256 i = 0; i < n; i++) {\n            address facet = facetAddrs[i];\n            if (facet == address(0)) revert ZeroAddress();\n            if (facet == address(this)) revert FacetIsSelf();\n            uint256 sz = facet.code.length;\n            if (sz == 0) revert ZeroCodeFacet(facet);\n            if (sz > MAX_FACET_CODE) revert CodeSizeExceeded(facet, sz);\n\n            // verify leaf against committed root (ordered Merkle)\n            bytes32 leaf = OrderedMerkle.leafOfSelectorRoute(selectors[i], facet, codehashes[i]);\n            bool ok = OrderedMerkle.verify(proofs[i], isRight[i], root, leaf);\n            if (!ok) revert InvalidProof();\n\n            _setRoute(selectors[i], facet, codehashes[i]);\n        }\n\n        uint64 oldVer = manifest.manifestVersion;\n        manifest.manifestVersion = oldVer + 1;\n        emit ManifestVersionUpdated(oldVer, manifest.manifestVersion);\n    }\n\n    /// @notice Activate the committed root after the delay.\n    function activateCommittedRoot()\n        external\n        override\n        onlyRole(APPLY_ROLE)\n        whenNotPaused\n    {\n        if (manifest.frozen) revert FrozenContract();\n        bytes32 pending = manifest.pendingRoot;\n        if (pending == bytes32(0)) revert NoPendingRoot();\n\n        uint64 earliest = manifest.committedAt + manifest.activationDelay;\n        uint64 nowTs = uint64(block.timestamp);\n        if (nowTs < earliest) revert ActivationNotReady(earliest, nowTs);\n\n        manifest.activeRoot = pending;\n        manifest.activeEpoch += 1;\n        manifest.pendingRoot = bytes32(0);\n        manifest.committedAt = 0;\n\n        uint64 oldVer = manifest.manifestVersion;\n        manifest.manifestVersion = oldVer + 1;\n\n        emit RootActivated(manifest.activeRoot, manifest.activeEpoch);\n        emit ManifestVersionUpdated(oldVer, manifest.manifestVersion);\n    }\n\n    /// @notice Emergency removal of routes (audit-visible, does not change active root).\n    function removeRoutes(bytes4[] calldata selectors)\n        external\n        override\n        onlyRole(EMERGENCY_ROLE)\n        whenNotPaused\n    {\n        uint256 n = selectors.length;\n        if (n > MAX_BATCH) revert BatchTooLarge(n);\n        bool changed;\n        for (uint256 i = 0; i < n; i++) {\n            bytes4 sel = selectors[i];\n            address oldFacet = _routes[sel].facet;\n            if (oldFacet != address(0)) {\n                delete _routes[sel];\n                if (registeredSelectors[sel]) {\n                    registeredSelectors[sel] = false;\n                    if (routeCount > 0) routeCount--;\n                }\n                _removeSelectorFromFacet(oldFacet, sel);\n                emit RouteRemoved(sel);\n                changed = true;\n            }\n        }\n        emit RoutesRemoved(selectors);\n        // bump manifest version for off-chain observers if any route changed\n        if (changed) {\n            uint64 oldVer = manifest.manifestVersion;\n            manifest.manifestVersion = oldVer + 1;\n            emit ManifestVersionUpdated(oldVer, manifest.manifestVersion);\n        }\n    }\n\n    /// @notice Update activation delay (admin).\n    function setActivationDelay(uint64 newDelay)\n        external\n        override\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        if (manifest.frozen) revert FrozenContract();\n        if (newDelay > MAX_ACTIVATION_DELAY) revert ActivationDelayOutOfRange(newDelay);\n        uint64 old = manifest.activationDelay;\n        manifest.activationDelay = newDelay;\n        emit ActivationDelaySet(old, newDelay);\n    }\n\n    /// @notice One-way freeze of governance mutators.\n    function freeze()\n        external\n        override\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        if (manifest.frozen) revert FrozenContract();\n        manifest.frozen = true;\n        emit Frozen();\n    }\n\n    /// @notice Pause/unpause routing (emergency role).\n    function pause()  external override onlyRole(EMERGENCY_ROLE) { _pause(); }\n    function unpause() external override onlyRole(EMERGENCY_ROLE) { _unpause(); }\n\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    // EIP-2535 Loupe (standard)\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    function facetAddresses() external view override(IDiamondLoupe) returns (address[] memory) {\n        return _facetAddresses;\n    }\n\n    function facetFunctionSelectors(address facet) external view override(IDiamondLoupe) returns (bytes4[] memory) {\n        return facetSelectors[facet];\n    }\n\n    function facetAddress(bytes4 selector) external view override(IDiamondLoupe) returns (address) {\n        return _routes[selector].facet;\n    }\n\n    function facets() external view override(IDiamondLoupe) returns (IDiamondLoupe.Facet[] memory out) {\n        uint256 n = _facetAddresses.length;\n        out = new IDiamondLoupe.Facet[](n);\n        for (uint256 i = 0; i < n; i++) {\n            address fa = _facetAddresses[i];\n            out[i] = IDiamondLoupe.Facet({ facetAddress: fa, functionSelectors: facetSelectors[fa] });\n        }\n    }\n\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    // ERC165: advertise supported interfaces\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControl)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IDiamondLoupe).interfaceId ||\n            interfaceId == type(IDiamondLoupeEx).interfaceId ||\n            interfaceId == type(IManifestDispatcher).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    // Enhanced Loupe (Ex)\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    function facetAddressesEx(bool includeUnsafe)\n        external\n        view\n        override(IDiamondLoupeEx)\n        returns (address[] memory facetAddresses_)\n    {\n        uint256 n = _facetAddresses.length;\n        if (includeUnsafe) {\n            facetAddresses_ = new address[](n);\n            for (uint256 i = 0; i < n; i++) {\n                facetAddresses_[i] = _facetAddresses[i];\n            }\n        } else {\n            uint256 count;\n            for (uint256 i = 0; i < n; i++) {\n                if (_facetSecurityLevel[_facetAddresses[i]] > 0) count++;\n            }\n            facetAddresses_ = new address[](count);\n            uint256 idx;\n            for (uint256 i = 0; i < n; i++) {\n                address fa = _facetAddresses[i];\n                if (_facetSecurityLevel[fa] > 0) {\n                    facetAddresses_[idx++] = fa;\n                }\n            }\n        }\n    }\n\n    function facetFunctionSelectorsEx(address facet, uint8 minSecurityLevel)\n        external\n        view\n        override(IDiamondLoupeEx)\n        returns (bytes4[] memory selectors_)\n    {\n        if (_facetSecurityLevel[facet] < minSecurityLevel) {\n            return new bytes4[](0);\n        }\n        selectors_ = facetSelectors[facet];\n    }\n\n    function facetsEx(bool /*includeMetadata*/)\n        external\n        view\n        override(IDiamondLoupeEx)\n        returns (IDiamondLoupeEx.FacetEx[] memory facets_)\n    {\n        uint256 n = _facetAddresses.length;\n        facets_ = new IDiamondLoupeEx.FacetEx[](n);\n        for (uint256 i = 0; i < n; i++) {\n            address fa = _facetAddresses[i];\n            facets_[i] = IDiamondLoupeEx.FacetEx({\n                facetAddress:      fa,\n                functionSelectors: facetSelectors[fa],\n                versionTag:        _facetVersionTag[fa],\n                securityLevel:     _facetSecurityLevel[fa]\n            });\n        }\n    }\n\n    function facetAddressEx(bytes4 functionSelector, bytes32 requiredVersion)\n        external\n        view\n        override(IDiamondLoupeEx)\n        returns (address facetAddress_)\n    {\n        address fa = _routes[functionSelector].facet;\n        if (fa == address(0)) return address(0);\n        if (requiredVersion == bytes32(0) || _facetVersionTag[fa] == requiredVersion) {\n            return fa;\n        }\n        return address(0);\n    }\n\n    function facetAddressesBatchEx(bytes4[] calldata functionSelectors)\n        external\n        view\n        override(IDiamondLoupeEx)\n        returns (address[] memory facetAddresses_)\n    {\n        uint256 n = functionSelectors.length;\n        facetAddresses_ = new address[](n);\n        for (uint256 i = 0; i < n; i++) {\n            facetAddresses_[i] = _routes[functionSelectors[i]].facet;\n        }\n    }\n\n    function facetMetadata(address /*facet*/)\n        external\n        view\n        override(IDiamondLoupeEx)\n        returns (IDiamondLoupeEx.FacetMetadata memory metadata_)\n    {\n        metadata_.name          = \"\";\n        metadata_.category      = \"\";\n        metadata_.dependencies  = new string[](0);\n        metadata_.isUpgradeable = true;\n    }\n\n    function checkStorageConflicts(address /*facet*/)\n        external\n        view\n        override(IDiamondLoupeEx)\n        returns (bytes32[] memory conflicts_)\n    {\n        conflicts_ = new bytes32[](0);\n    }\n\n    function facetImplementation(address /*facet*/)\n        external\n        view\n        override(IDiamondLoupeEx)\n        returns (address implementation_)\n    {\n        implementation_ = address(0);\n    }\n\n    function facetHash(address facet)\n        external\n        view\n        override(IDiamondLoupeEx)\n        returns (bytes32)\n    {\n        return facet.codehash;\n    }\n\n    function selectorHash(address facet)\n        external\n        view\n        override(IDiamondLoupeEx)\n        returns (bytes32)\n    {\n        return _selectorHash(facet);\n    }\n\n    function facetProvenance(address facet)\n        external\n        view\n        override(IDiamondLoupeEx)\n        returns (address deployer, uint256 deployTimestamp)\n    {\n        deployer        = _facetDeployer[facet];\n        deployTimestamp = _facetDeployedAt[facet];\n    }\n\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    // Preflight helpers (upgrade-time checks via RefactorSafetyLib)\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    /**\n     * @notice Validate a facet upgrade off-chain before applying routes.\n     * @param facet Address of the facet being (re)registered\n     * @param expectedCodeHash Expected EXTCODEHASH (bytes32(0) to skip)\n     * @param claimedSelectors The full selector set the facet is expected to expose after the upgrade\n     * @param allowAdditions Whether new selectors are allowed compared to existing set\n     * @return ok True if codehash is OK; selector compatibility reverts on failure\n     * @return selectorHashEx Current selector hash fingerprint for the facet (for auditing)\n     */\n    function preflightCheckFacet(\n        address facet,\n        bytes32 expectedCodeHash,\n        bytes4[] calldata claimedSelectors,\n        bool allowAdditions\n    ) external view returns (bool ok, bytes32 selectorHashEx) {\n        // 1) Codehash preflight (shallow)\n        ok = RefactorSafetyLib.performRefactorSafetyCheck(facet, expectedCodeHash, 0);\n\n        // 2) Selector compatibility against current registry (if facet already present)\n        bytes4[] storage cur = facetSelectors[facet];\n        bytes4[] memory oldS = new bytes4[](cur.length);\n        for (uint256 i = 0; i < cur.length; i++) {\n            oldS[i] = cur[i];\n        }\n        bytes4[] memory newS = new bytes4[](claimedSelectors.length);\n        for (uint256 j = 0; j < claimedSelectors.length; j++) {\n            newS[j] = claimedSelectors[j];\n        }\n        // Will revert with explicit error if incompatible\n        // RefactorSafetyLib.validateSelectorCompatibility(oldS, newS, allowAdditions);\n        RefactorSafetyLib.validateSelectorCompatibilityView(oldS, newS, allowAdditions);\n\n        // 3) Return current selector fingerprint for provenance\n        selectorHashEx = _selectorHash(facet);\n    }\n\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    // Internal helpers\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    function _setRoute(bytes4 selector, address facet, bytes32 codehash) internal {\n        // runtime integrity check\n        if (facet.codehash != codehash) revert FacetCodeMismatch(facet, codehash, facet.codehash);\n\n        address oldFacet = _routes[selector].facet;\n        _routes[selector] = IManifestDispatcher.Route(facet, codehash);\n\n        // registry book-keeping\n        if (!registeredSelectors[selector]) {\n            registeredSelectors[selector] = true;\n            routeCount++;\n            _addSelectorToFacet(facet, selector);\n            emit RouteAdded(selector, facet, codehash);\n        } else if (oldFacet != facet) {\n            _removeSelectorFromFacet(oldFacet, selector);\n            _addSelectorToFacet(facet, selector);\n            emit RouteUpdated(selector, oldFacet, facet);\n        }\n\n        // provenance / defaults for Enhanced Loupe\n        if (_facetDeployer[facet] == address(0)) {\n            _facetDeployer[facet]  = msg.sender;\n            _facetDeployedAt[facet] = uint64(block.timestamp);\n        }\n        if (_facetSecurityLevel[facet] == 0) {\n            _facetSecurityLevel[facet] = 1; // default \"user\" level\n        }\n        // _facetVersionTag[facet] remains bytes32(0) unless set via governance (out of scope here)\n    }\n\n    function _addSelectorToFacet(address facet, bytes4 selector) internal {\n        bytes4[] storage sels = facetSelectors[facet];\n        for (uint256 i = 0; i < sels.length; i++) {\n            if (sels[i] == selector) return;\n        }\n        if (sels.length == 0) {\n            // first time we see this facet\n            _facetAddresses.push(facet);\n        }\n        sels.push(selector);\n    }\n\n    function _removeSelectorFromFacet(address facet, bytes4 selector) internal {\n        bytes4[] storage sels = facetSelectors[facet];\n        for (uint256 i = 0; i < sels.length; i++) {\n            if (sels[i] == selector) {\n                sels[i] = sels[sels.length - 1];\n                sels.pop();\n                break;\n            }\n        }\n        // drop facet if empty\n        if (sels.length == 0) {\n            uint256 n = _facetAddresses.length;\n            for (uint256 i = 0; i < n; i++) {\n                if (_facetAddresses[i] == facet) {\n                    _facetAddresses[i] = _facetAddresses[n - 1];\n                    _facetAddresses.pop();\n                    break;\n                }\n            }\n        }\n    }\n\n    function _selectorHash(address facet) internal view returns (bytes32) {\n        // Copy selectors and sort in-memory for a deterministic hash\n        bytes4[] memory sels = facetSelectors[facet];\n        uint256 n = sels.length;\n        // insertion sort (small n typical)\n        for (uint256 i = 1; i < n; i++) {\n            bytes4 key = sels[i];\n            uint256 j = i;\n            while (j > 0 && uint32(sels[j - 1]) > uint32(key)) {\n                sels[j] = sels[j - 1];\n                unchecked { --j; }\n            }\n            sels[j] = key;\n        }\n        return keccak256(abi.encodePacked(facet.codehash, sels));\n    }\n\n    /// @notice DEV-ONLY: Directly register routes without Merkle proofs.\n    /// @dev Intended for local/test networks to enable fast demos and CI smoke tests.\n    ///      Enforced via APPLY_ROLE and whenNotPaused; also rejects self/zero/oversized facets.\n    /// @param facets_    List of facet addresses\n    /// @param selectors_ Parallel list of selector arrays corresponding to each facet\n    function adminRegisterUnsafe(address[] calldata facets_, bytes4[][] calldata selectors_)\n        external\n        onlyRole(APPLY_ROLE)\n        whenNotPaused\n    {\n        uint256 n = facets_.length;\n        if (n == 0) return;\n        if (n != selectors_.length) revert LenMismatch();\n        if (n > MAX_BATCH) revert BatchTooLarge(n);\n\n        for (uint256 i = 0; i < n; i++) {\n            address facet = facets_[i];\n            if (facet == address(0)) revert ZeroAddress();\n            if (facet == address(this)) revert FacetIsSelf();\n            uint256 sz = facet.code.length;\n            if (sz == 0) revert ZeroCodeFacet(facet);\n            if (sz > MAX_FACET_CODE) revert CodeSizeExceeded(facet, sz);\n            bytes32 ch = facet.codehash;\n\n            bytes4[] calldata sels = selectors_[i];\n            uint256 m = sels.length;\n            if (m > MAX_BATCH) revert BatchTooLarge(m);\n            for (uint256 j = 0; j < m; j++) {\n                _setRoute(sels[j], facet, ch);\n            }\n        }\n\n        uint64 oldVer = manifest.manifestVersion;\n        manifest.manifestVersion = oldVer + 1;\n        emit ManifestVersionUpdated(oldVer, manifest.manifestVersion);\n    }\n\n    /// @notice Apply a single route update (low-level, bypassing Merkle proof).\n    function applyRouteOne(\n        bytes4 selector,\n        address facetAddr,\n        bytes32 codehash,\n        bytes32[] calldata proof,\n        bool[] calldata isRight_\n    ) external onlyRole(APPLY_ROLE) whenNotPaused {\n        bytes4[] memory selectors = new bytes4[](1);\n        address[] memory facets_ = new address[](1);\n        bytes32[] memory codehashes = new bytes32[](1);\n        bytes32[][] memory proofs = new bytes32[][](1);\n        bool[][] memory isRight = new bool[][](1);\n        selectors[0] = selector;\n        facets_[0] = facetAddr;\n        codehashes[0] = codehash;\n        proofs[0] = proof;\n        isRight[0] = isRight_;\n        this.applyRoutes(selectors, facets_, codehashes, proofs, isRight);\n    }\n\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    // Governance helpers for facet metadata\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    function setFacetSecurityLevel(address facet, uint8 level)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        if (manifest.frozen) revert FrozenContract();\n        // Require known facet (provenance set on first registration)\n        if (_facetDeployer[facet] == address(0)) revert FacetUnknown(facet);\n        // Allow 0 = hidden/unsafe; bound upper levels to a small range for consistency\n        if (level > 3) revert InvalidSecurityLevel(level);\n        _facetSecurityLevel[facet] = level;\n        emit FacetSecurityLevelSet(facet, level);\n    }\n\n    function setFacetVersionTag(address facet, bytes32 tag)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        if (manifest.frozen) revert FrozenContract();\n        if (_facetDeployer[facet] == address(0)) revert FacetUnknown(facet);\n        _facetVersionTag[facet] = tag;\n        emit FacetVersionTagSet(facet, tag);\n    }\n}\n",
  "selectors": [
    "routes(bytes4 selector)",
    "pendingRoot()",
    "pendingEpoch()",
    "pendingSince()",
    "activeRoot()",
    "activeEpoch()",
    "activationDelay()",
    "frozen()",
    "getManifestVersion()",
    "getRoute(bytes4 selector)",
    "getRouteCount()",
    "facetSecurityLevel(address facet)",
    "facetVersionTag(address facet)",
    "getLimits()",
    "verifyManifest(bytes32 manifestHash)",
    "getManifestInfo()",
    "commitRoot(bytes32 newRoot, uint64 newEpoch)",
    "applyRoutes(bytes4[] calldata selectors,\n        address[] calldata facetAddrs,\n        bytes32[] calldata codehashes,\n        bytes32[][] calldata proofs,\n        bool[][]   calldata isRight)",
    "activateCommittedRoot()",
    "removeRoutes(bytes4[] calldata selectors)",
    "setActivationDelay(uint64 newDelay)",
    "freeze()",
    "pause()",
    "unpause()",
    "facetAddresses()",
    "facetFunctionSelectors(address facet)",
    "facetAddress(bytes4 selector)",
    "facets()",
    "supportsInterface(bytes4 interfaceId)",
    "facetAddressesEx(bool includeUnsafe)",
    "facetFunctionSelectorsEx(address facet, uint8 minSecurityLevel)",
    "facetsEx(bool /*includeMetadata*/)",
    "facetAddressEx(bytes4 functionSelector, bytes32 requiredVersion)",
    "facetAddressesBatchEx(bytes4[] calldata functionSelectors)",
    "facetMetadata(address /*facet*/)",
    "checkStorageConflicts(address /*facet*/)",
    "facetImplementation(address /*facet*/)",
    "facetHash(address facet)",
    "selectorHash(address facet)",
    "facetProvenance(address facet)",
    "preflightCheckFacet(address facet,\n        bytes32 expectedCodeHash,\n        bytes4[] calldata claimedSelectors,\n        bool allowAdditions)",
    "adminRegisterUnsafe(address[] calldata facets_, bytes4[][] calldata selectors_)",
    "applyRouteOne(bytes4 selector,\n        address facetAddr,\n        bytes32 codehash,\n        bytes32[] calldata proof,\n        bool[] calldata isRight_)",
    "setFacetSecurityLevel(address facet, uint8 level)",
    "setFacetVersionTag(address facet, bytes32 tag)"
  ],
  "size": 33318
}